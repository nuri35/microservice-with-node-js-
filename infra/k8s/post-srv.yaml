apiVersion: v1
kind: Service
metadata:
  name: client-srv
spec:
  type: NodePort
  selector:
    app: client
  ports:
    - name: client
      protocol: TCP
      port: 3000 
      targetPort: 3000 #uygulamanın calıstıgı porttur. buraya yonlendırır porttan targetporta...Okey

#şimdi içinde kubernete cluster calısan contanierın  container ip sine baktım minikube ip dedııgmle aynı  çok normal zaten minikube ip deıdgımde o makınanın ipsini verecektır. oda container dedıgımız sanal mkına zaten okeyyy.... peki neden 192.168.49.2:32616 dedıgımızde yanı oda zaten direk 3000'maplenmış oldugu ıcın dolaylı yoldan bız dışardan 3000 portuna ulasıyoz oda 3000:3000 gibi davranıyor en sagdakı 3000 de kı uygulamaya gıder zaten  tabı selectora bakarak 

#anladıgın kadarıla    post koduna dışardan ulaşıp postmanden yada urlden get post isteklerı atıp event bus poduna erısebılyıorsun ama react podundan backend yanı posts poduna erişemedın örnegın posts/create endpoıntıne ıstek atamadın. Bu sorunu çözmek için arka uç sunucusunun istemciden erişilebilir olması gerekir. Bu, arka uç bölmesiyle ilişkili hizmeti bir LoadBalancer olarak değiştirerek veya bir giriş kullanarak yapılabilir ingress controller vs kullanbılrsın. bende de node port ile yapamadım onu daha cok tek bir podu başka pod ile iletişim iiçin vs denersın nodePort servisi BAK KULLANMAMAK ICIN BİR NEDEN

# Bu hatayı yerel makineden alıyorsunuz çünkü ClusterIP hizmeti küme dışından erişim için yanlış türde. Kubernetes belgelerinde belirtildiği gibi ClusterIP'ye yalnızca küme içinden erişilebilir yanı aslında clıent podumuzda dışarı olarak kabul edılıyor.
#şöyle birşey anladım react pod'u da ıcerde olarak anlayıp asında konusması lazım posts poduyla ama clıent'da gosterılen ıstekler dışardanmış tarayıcıdan atılıyor gibi oluyor dolayısıyla dışardan da post'a ulaşım olmadıgı ıcın sankı dışardan post koduna ulasıyormusuz gıbı oluyor ama bız aslında react podu ıcerde ve ıcerdekı başka pod ile konusmasını ıstedıgımız ıcın o da oyle davranmadıgı ıcın olmuyor. fakat gel gelelim bir post servisimizi dışarıya açsak ulasırız hatta post create endpointiyle post istegı atıpp event bus poduylada konusabılır cunku  o express uygulaması içerden 2 pod olarak birbirleryıle konusyorsun oluyor. react poduna dışardan ulaşıpp sıte ıcersınde query'e ıstek attıgında sankı dışardan istek atılıyormus gıbı react poduyla query podu ıcerden bırbırlerıyle konusuyormus gıbı olmuyor. maalesef araştırmalarına göre böyle onun ıcın node port kullanma react backend uygulamalarında.

# react bakcend gıbı buyuk  clone projen ıcın nodeport kullanmıyoruz onunda ornegınıde işledik.bakarsın pekı ne yapıyoruz : 
# ----------------------------------------
# react uygulamamızız aslında deveplopment server'dır. react app dev server'ada bir pod ıcınde barındırıyoruz ve buuda node kumemızın ıcınde yer alacak.bu pod'un ıcınde yer alan react app dev server ne yaptıgına dair fikir vermek gerekirse ;  bir kullanıcı  browserdan uygulamayı  acıtıgmıız zaman react uygulama geliştirme suncuunsuna yanı react app uygulamamızıa baglanacagız dışardan. bu react app dev server'ın tek amacı  sizin bir react uygulamasının ıcın yazdıgmız kodu almak ve daha sonra bundan bazı  js + css + html  dosyaları oluşturmakdır. dolayısıyla bu kumenın ıcınde calısan uygulamamıza ılk navıgasyon gırısımı sırasında  bu react uygulama geliştirme sunucusunn yaptıgı tek sey bazı html css ve js dondurmektir.

# ama pod'un ıcınde bulunan react app dev server'ın tek yapmadıgı şey herhangı bır noktada posts comments vs bu podlara istekde bulunmamasıdır.veriler için asıl talep kullanıcnın tarayıcınsdan yapılmaktadır. react uygulaması kullanıcının tarayıcısında acılır   ve ardından tarayıcının içinde react uygulaması sorgu hızmetıne ulaşmaya calısacaktır ve ilk html css js ogelerını sunduktan sonra bazi gonderılerı ve yorumları alacaktır. işte bu sırada bu node clustur ıcınde bulunan pod'un ıcınde var olan react app dev server'ın hıcbır onemı yok. bu nedenle pod'un ıcınde olan react app server  bu geliştirme suncuunsundan dogrudan dıger potlarımıza  istek gonderılmıyor. ornegın query pod'una ıstek dırek tarayıcıdan gelmektedır. buda bır sorun yaratmaktadır.


#-----------------------------------------------------------------------
#pekı react uygulamasının bır sekılde tum bu farklı pod'lara ıstekde bulunabılmeısnı nasıl saglayacagız ? en azından tarayıcdan query pod'una ulaşmamız lazım get ile yorumları ve postları alabılmek adına.yada  post create etmemız lazım  2 seçenek var 2.cisini her zaman uygulucaz

# 1.seçenek olarak react uygulamasının ıcınde postları alabılmek ıcın query endpoıntıne ıstek atıyor ornegın. bunu browser yaptıgı ıcınde bızım query pod'unu nodeport ile dışarıya açarsak bir çözüm olur dıger podlarıda nodeport ıle dışarı açarsın . böylelikle react app uygulmasında yapılan istekler tarayıcı olarak yaptıgından zaten istek attıgı pod'da dışarıya acıldıgı ıcın iletişim saglanır ama önerilmeyen bir yöntem. zaten onerılmemesının sebebı nodeport baglantı noktası olarak 3 ile başayan rastgele bir sayı veriyor.farklı olma ıhtımalı var. yanı ne yapmak zorunda kalırdın şöyle post create edecegın zaman posts pod'u nodeport ile dışarıya acılmış vaziyette react uygulaması ıcınde post create endpointine http://minikubeİP:32335/posts/create gibi birşey yapacaktın. 2.yöntem deneyecegız

# 2.yöntem load balancer service . dogru yol budur deveplopment ve production envriment içinde tek dogru yol budur.
#--------------------------------
# bir load balancer tipi servis oluşturacagız. bunun tek amacı tum kumemıze tek bir giriş noktasına sahip olmasıdır browser kısmında reat uygulammamızın bu yuk dengeleyıcı hızmetıne erişmek için istekde bulunacagından  emın olacagız ve ardından bazı mantıklar ekleyecegız. dolayısıyla load balancer hizmetin içidekı gercek kod ve yapılandırma gelen bu ısteklerı alacak ve bunu uygun ıstenılen pod'a yondelndırecektır.yanı cluster ıcınde react app dev server'ın burda bir görevi olmayacak o yonlendırmıyor uygun pod'a . tum bunlar load balancer hızmetı etrafında olacak.dolayısıyla şimdi pod'un ıcındekı react uygulamasının ıcınde isteklerın atıldıgı yerde endpoıntte bıraz ayarlar yapmamız gerekecektir let's go. pod'un ıcındekı react uygulamamızda react app dev server oluyor işte....... react app running in browser kısmına js +css + html dondurur sadece unutma 

#  kb8 dunyaında gercekten 2 farklı şey bulunmaktadır ilki load balancer service  adı verılen birşey vardır. ayruca 2.ci olarak  ingress veya ingress controller olarak adlanıdırlan ve cok yakından ılıskılı olan bir şey daha vadır. teknık olarak ıngress or ingress controller iki farklı şeydir. bunları bırbıınrın yerıne kullanılabılecek terımlerle ıfade edecegız.

#-------------------------------
# load balancer service  hızmetı kubernetese yada ozellıkle kumemıze saglaycısına,pod'a ulaşmasını soyleyen birşey olacaktır.amacı trafigi tek bir bölmeye almaktır.
# öte yandan ıngress ve ıngress controller yine teknık olarak farklı şeylerdir.fakat bırbırnın yerıne kullancagız. trafigi kumemızdekı (clusterdaki) diger hizmetlere dagıtacak bir dizi yönlendirme kuralına sahip bir poddur.


# ilk önce load balancer gerçekte ne oldugna odaklanacagız  :  91.ders 1.55dekı gorsele bakabılrız. bir cloud provider var  yanı aws ,azure gibi bir sanal makına ıcıne kubernetes cluster'ımız bulunmaktadır. ve cluster ıcındede bazı pod'lar var. dış dunyadan gelen bır trafıgı veya ag ısteklerını bır sekılde kumemızın ıcındekı bır poda aktrmak istecegız.pekı bunu load balancer ıle nasıl yaparız. tabıkıde bır loadnalancer service config file'ımız hazırlayaacagız. fakat nasıl load balancer kullanarak yaparız. anlatacagım...... bu confıg fıle'ı -f apply komutunu kullnarak cluster'a ıletırız.
#----------------------------
# şimdiye kadar k8s ıle ılgılı tartıştıgımız nesnelerın hemen hepsı dogrudan  cluster ıcınde olusutrulan seylerle ılgılıydı boylece kume ıcınde servıce podlar deploymentslar olusturduk. lload balancer service'ı bıraz farklıdır.bu config file for a loadbalancer service sayesinde (load balancer service) load balancer servısı cluster'a bulut saglayıcınsına ulaşmasını soyleyecek yanı azure aws gibi cloud provider'ına . bu nedenle dogrudan aws azure'a ulaşın ve  load balancer adı verılen birşey saglayın. bu servıs tamamen kümemizin dısında bulunmaktadır.ayrıca google cloud veya aws azure'un bir parçasıdır. bu servıs'de dış dunyadan gelen trafıgı almak ve cluster ıcındekı bır poda yonlendırmek ıcın kullanılacaktır.yanı aslında cloud provider'ın azure'ın vs bir özellıgıdır bu load balancer service. aslında load balancer servıce'ının amacı cluster'ımıza  cluster'dakı bir pod'a  biraz tarafik alma amacı taşıyan bir yük dengeleyıcı olan  cloud providerına  ulaşmasını söyler.  şuanlık tek başına load balancer cok kullanıslı degıldır. zaten bıızım amacımız trafııgı bır dıızı farklı pod'a dagıtılmasını ve bu trafıgın nereye gondereılecegıne karar vermek oldugu ııcn yanı şu rotaya bir istekte bulunun dıyebılsek ve kumemızın etrafında bir şeyy varsa bu ıstegın hangı pod'a ıletılmesını gerektıgını bulsak harika olurdu . yanı yuk dengeleyıcı tek basına bızım ıcın tam olarak bireşy yapmıyor ihtiyacımız olan herşeyi yapmıyor. . işte bu noktada ingress controller ve ıngress girecektir.


# ingress or ingress controller ; içinde bir dizi yönlendirme kuralı bulunan bir poddur.load balancer  servisi ile birlikte çalışacaktır.anlatmak gerekrıse ;

#---------------------
# bir cloud provider'ımız olsun azure vs sanal makınamız yanı dışardan bir trafık gelecek makınamıza  ve cluster ıcınde 4 tane farklı pod'umuz var . query posts comments gibi podlar. dolayısıyla cloud proverdırımız ile bırlıkte saglanan bir load balancer hale gelen bir istegimiz olacak. yanı ilk dısardan gelen istek load balancer'da olacak  burdan bu alacak ıstegı ıngress controller'a yonlendırecek ıste ıngress conroller da bızıım cluster'ımız ıcınde unutma. bu ıngress controller ıcınde bır dızıı yonlendırme kuralı olacaktır. bu ıngress controllerın  gelen ıstegın yoluna bakacagını ve ardından  bu yola dayanarak istegi şu poda vs seklınde yonlendırecektır.ve aslında ıstegı bır pod'a gonder dedıgımde aslında pod'a istek gonderen bir clusterIp service'ine gonder demek ıstıyorum. yanı teknık olarak ıngress controller ıle pod arasında clusterIpler bulunmaktadır.resimdede öyle . 

# bu ıngress olayında load balancer sadece trafıgı cluster'ımıza aktarmakla ılgılıdır.ıngress controller olayı ise yonlendırme kuralları veya ısteklerı uygun poda gonderecek bazı yonlendırme yapılandırmalarına sahıp olmakla ılgılıdır.

# sımdı oncesınde cluster dısında load balancer olması ıcın  ve clustet'dda kullancagımız ıngress controller'ın gerçek uygulamasına bir bakalım. işte ingress-nginx adında bir uuygulamadan yararlanacaz bu uygulama load balancer service ve ingress create etmektedir.  https://kubernetes.github.io/ingress-nginx/deploy/#minikube sitesinde türlü yükleme var minikube addons enable ingress komutuyla ingress controller cluster ıcındekı yanı enable edebılıyoruz sanırsam birde cluster dıısındakı loadbalancer 'da  şemadakı bahsettigim  yanı oluşuyor. bu ıngress controller sayesınde yanı bu ıngress controller içinde bir dizi yönlendirme kuralına sahip olacak ve gelen trafıgın uygun bir bölmeye gonderılmesını saglayacaktır.sonuç olarak 93.dersdekı 6.17'dekı şemayı uyguluyoruz. load balancer ise  dışarıdan yuk dengeleyıcı saglayacak ve bir sekilde trafigi ingress controller'a sokacak.


# There are multiple ways to install the NGINX ingress controller: 

# with Helm, using the project repository chart;
# with kubectl apply, using YAML manifests;
# with specific addons (e.g. for minikube or MicroK8s).


# şimdi ingress controllera trafıgı farklı pod setlerimize nasıl yonlendırecegını nasıl soyleriz buna bakalım bunu bazı yonlendırıcı kuralları ıceren bır config file yazarak yapacagız ingress-srv.yaml'a bakabılrısn